Калькулятор обмена криптовалюты
Предложу реализацию на React.
Это будет компонет CryptoCalc, который можно будет интегрировать в основное приложение.
При первом рендере компонента при помощи useEffect будем получать c API валидный список пар валют (validPairs). В условии задачи не указано, как часто этот список будет обновляться, поэтому допустим, что нам достаточно его получения при первом рендере компонента.

Будем использовать управляемые импуты с целью упрощения валидации ввода.
Для начала получим список валидных базовых валют 

// Предусмотрим, что список должен быть уникальным

let validCurrencyList = [...new Set(validPairs.map(({symbol}) => symbol))]

На основе этого списка мы можем отрендерить ввод базовой валюты в общем виде так:

<select>
{validCurrencyList.map(currency)=>{
    <option key={currency.toLowerCase} value = {currency}> {currency}</option>
}
</select>

обработчик будет менять стейт и устанавливать текущую базовую валюту currentBase через useState  и setCurrentBase

для вывода списка котируемой валюты отфильтруем список валидных пар по symbol === currentBase и возьмем свойство quote

таким образом мы сделали валидацию по вводу валют.

на основе пары валют делаем запрос на курс, комиссию и минимальные/максимальные суммы.
комиссию можем вывести в отдельном элементе, а суммы в label для удобства пользователя.

поскольку у нас управляемый ввод в обработчике мы сразу можем поставить проверку на тип вводимой информации (число) и попадание его в диапазон мин/макс

расчет итоговой суммы можно поместить в обработчик, либо сделать по отдельной кнопке "посчитать"

в любом случае, при расчета сначала производится проверка устаревания данных. По таймстампу. Если текущий отстает более чем на 600 секунд делается новый запрос.

исходя из условий расчет ведется либо по дефолтной формуле, либо по кастомной.

это подразумевает, что у нас есть объект 

customFormulas = {
    abcd: function1()
}

// можно добавить необходимое количество функций

function calculate(amount, price, fee, type, formulaId) {
  if (type === "custom" && customFormulas[formulaId]) {
    return customFormulas[formulaId](amount, price, fee);
  }
  return defaultFormula(amount, price, fee);
}

для обработки ошибок используются стандартные средства в момент получения 
данных курсе и комиссии. Примерно так

async function fetchData(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`Ошибка: ${response.status}`);
    }
    return await response.json();
  } catch (error) {
    console.error("Ошибка загрузки данных:", error.message);
    alert("Ошибка сервера. Попробуйте позже!");
  }
}

Для тестирования следует проверить работу на всех парах, ввод невалидных значение в поле суммы и, возможно нагрузочную способность (много запросов, частое обращение к API)
